<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <!--
<link rel="stylesheet" type="text/css" href="../css/issStyle1.css">
<script type="text/javascript" src="../css/issStyle.js"></script>
-->
<style type="text/css">
    body
    {
        margin-left:  30px;
        margin-right: 30px;
    };
    
    P
    {
        font-family: Tahoma;
        font-size: 10pt;
    };
    
    a, a:visited, a:active, a:link, a:hover {
        text-decoration: underline;
        color: #545454;
        background-color: transparent;
        font-size: 93%;
    }
    
    a:hover {
        background-color: #cccccc;
    }
    
    
    hr {
        clear: both;
        height: 1px;
        color: #242424;
        background-color: transparent;
    }
    
    h1, h2, h3 {
        color: #242424;
        clear: left;
        font: 100% Tahoma, Helvetica, Arial, sans-serif;
        margin-bottom: 0.5em;
        padding-top: 0.5em;
        border-radius: 10px;
        padding: 5px;
    }
    
    top {
        width: 100%;
    }
    
    
    #i {
        color: #ff1010;
    }
    tt{
        font-family: "Arial";
        font-size: 90%;
        color: #006600;
    }
    em{
        font-family: "Arial";
        font-size: 80%;
        font-weight: bold;
        border-style:solid;
        border-color: #abe876;
        color: #1632cc;
    }
    bc{
        font-family: "Arial";
        font-size: 90%;
        font-weight: bold;
        color: #990000;
        background-color: #fcf8c7;
    }
    ks{
        font-family: "Arial";
        font-weight: bold;
        color: #0000CD	;
        font-size: 90%;
    }
    kc{
        font-family: "Arial";
        font-weight: bold;
        color: #008000	;
        font-size: 90%;
    }
    pre{
        font-family: "Consolas";
        font-size: 85%;
        background-color: #f5f5f5;
        border: 1.5px solid silver;
        padding: 5px;
    }
    m{
        font-family: "Helvetica";
        line-height: 100%;
         font-size: 75%;
    }
    div.body{
         
        font-size: 18px;
    }
    k{
        color: #990000;
        font-weight: bold;
        font-size: 90%;
    }
    h1 {
        font-size: 150%;
        background-color: #b2c0ff;
        padding: 10px;
    }
    
    h2 {
        background-color: #9ed8ff;
        font-size: 130%;
    }
    
    h3 {
        background-color: #e6ccff;
        font-size: 100%;
    }
    h4 {
        background-color: #ccffcc;
        font-size: 100%;
        width: 95%;
        border-radius: 5px;
        padding: 2px;
    }
    h5 {
        background-color: #d5ffb0;
        font-size: 100%;
    
    }
    div.req{
        background-color: #d9ffb3;
        font-size: 18px;
        width: 700px;
        border: 3px solid green;
        padding: 15px;
        margin: 10px;
    }
    div.remark{
        background-color: #E3F2FD;
        border: 1.5px solid #d5f2ed;
        padding: 15px;
        margin: 10px;
        border-radius: 25px;
    }
    table, th, td {
      border: 1px solid black;
      border-collapse: collapse;
    }
    
    ol, ul, li {
      margin: 0;
      margin-left: 10px;
      padding: 0;
      padding-bottom: 5px;
    }
    
    table, th, td {
        border: 1px solid black;
    }
    
    img {
        border: 1.5px solid #d5f2ed;
        
    
    }
    
    a, a:visited, a:active, a:link, a:hover {
        text-decoration: underline;
        color: #545454;
        background-color: transparent;
    }
    
    div.wrapdesc{
        width: 90%;
        margin: auto;
    }
    
    div.imagedesc{
        width: 85%;
        margin: auto;
    }
    </style>
        
    
<head>
   
<title>AnalisiFinale</title></head>
    
<body>
<div id="top">
<h1>ISS FINAL PROJECT 2022 - WasteService <font size="5"></font> </h1>
</div>  

<div class="body"> 
<h2>Introduction</h2>

    <div class="remark">
        Progetto finale del corso di Ingegneria dei Sistemi Software M, Laurea Magistrale di Ingegneria Informatica - Universit&agrave; di Bologna.
        L'obiettivo &egrave; simulare un impianto per la raccolta differenziata dei rifiuti, nel quale un robot, che funge da <strong>Transport Trolley</strong>, deve trasportare il materiale di scarto immesso da un porta nei relativi contenitori in base al tipo di oggetto, nello specifico si distinguer&agrave; tra oggetti in plastica e in vetro.
   </div>
 
<h2>Requirements</h2>
    <!-- <div class="remark">
        Una compagnia, per differenziare l'immondizia raccolta, intende costruire un WasteService composto da un set di elementi: <br>
        1. un'area di servizio (rettangolare, piatta) che include: <br>
            <ul>
                <li>una porta <em>INDOOR</em>, dove entra l'immondizia</li>
                <li>un container <em>PlasticBox</em>, che ha l'obiettivo di raccogliere gli oggetti plastica, fino a un MAXPB kg</li>
                <li>un container <em>GlassBox</em>, che ha l'obiettivo di raccogliere gli oggetti vetro, fino a un MAXGB kg</li>
            </ul> <br>
        L'area di servizio &egrave; libera da ostracoli interni, e si mostra come l'immagine che segue: <br>
        <img src="./img/WasteServiceRoom.PNG" width="100%" height="100%" ><br>
        2. Un robot DDR che funge da <strong>Transport Trolley</strong> e che inizialmente &egrave; situato nella sua posizione di <em>HOME</em>. Questo <strong>Transport Trolley</strong> ha la forma di un quadrato di lunghezza laterale <strong>RD</strong>.<br>
        
            <p>Il <cite><strong>Transport Trolley</strong></cite> viene utilizzato per <span class="blue">svolgere un'azione di deposito</span> che consiste nelle seguenti fasi:</p>
            
            <ol class="arabic simple">
                <li>raccogliere un carico di  <span class="blue">rifiuti da un camion dei rifiuti</span> situato all' <cite>INDOOR</cite></li>
                <li>passare dall' <cite>INDOOR</cite>all'apposito contenitore dei rifiuti</li>
                <li>depositare il carico di scarto nel contenitore</li>
            </ol>
            <br>

        3. Un <em>Service-manager</em>(un essere umano) che supervisiona lo stato dell'area di servizio utilizzando una <em>WasteServiceStatusGUI</em> <br>
        <br>
        4. Un <em>Sonar</em> e un <em>Led</em> collegati ad un RaspberryPy. Il led verr&agrave; usato come dispositivo di segnalazione, secondo il seguente schema:<br>
    
            <ul class="simple">
                <li>Il <cite>Led</cite> &egrave; <strong>spento </strong> il <strong>Transport Trolley</strong> &egrave; in <cite>HOME</cite></li>
                <li>Il <cite>Led</cite> <strong>lampeggia</strong> mentre il <strong>Transport Trolley</strong> &egrave; in movimento</li>
                <li>Il <cite>Led</cite> &egrave; <strong>acceso</strong> quando il <strong>Transport Trolley</strong> &egrave; fermo.</li>
            </ul>

            <p>
                Il <cite>Sonar</cite> invece viene usato come dispositivo di allarme: quando misura una distanza inferiore ad un valore prefissato  <strong>DLIMT</strong>,
                il <strong>Transport Trolley</strong> deve essere fermato. 
                Verr&agrave; ripreso quando il Sonar rilever&agrave; una distanza maggiore di <strong>DLIMT</strong>.
            </p>
               
        <h3>TFRequirement</h3>
        <h4>L'obiettivo del WASTESERVICE software &egrave; quello di permettere a un <i>camion dei rifiuti</i>  di depositare il proprio <i>TruckLoad</i>(kg) o di plastica o vetro nel container giusto(<i>PasticBOX,GlassBOX</i>). </h4>
            
            La simulazione pu&ograve; essere descritta come segue:       
            <ol class="arabic simple">
                <li>Il <i>camion dei rifiuti</i> approccia <i>INDOOR</i> area e manda (mediante uno "Smart Device") una richiesta di
                    di depositare il carico, specificando il tipo del materiale (plastica o vetro) e il suo <i>TruckLoad</i> .</li>
                <li>Il WASTESERVICE manda una risposta di <i>loadaccept</i> se il contenuto del finale del container giusto 
                    non sorpassa il valore massimo consentito (MAXPB or MAXGB). Altrimenti manda una risposta di <i>loadrejecetd</i>
                    e il <i>camion dei rifiuti</i>  lascia l'<i>INDOOR</i>  area.</li>
                <li>Quando il carico &egrave; accettato, il transport Trolley ragiunge l'<i>INDOOR</i> , prende il materiale,
                    va al giusto container e deposita il materiale. Durante il WASTESERVICE il Led lampeggia.</li>
                <li>Quando l'azione di deposito &egrave; terminata, il transport Trolley esegue un altro comando di deposito (se ce ne sono) o ritorna a casa.</li>
            </ol>
        

        <h4>Il WasteService deve creare una <i>WasteServiceStatusGUI</i> che permette al Service-manager di vedere:</h4>

         
            <ul>
                <li>Lo stato corrente del transport Trolley e il suo posizionamento nella stanza.</li>
                <li>Il peso corrente dei materiali presenti nei due container dei rifiuti.</li>
                <li>Lo stato corrente del Led.</li>
            </ul>
    </div>   -->
    <div class="remark">
        <a href="../Prof/TemaFinale22.html">Richieste del committente</a> </h2>
    </div>

<h2>Decisions made</h2>

<div class="remark">
<h3>Scelta QAK</h3>
    <p>
        Considerando le richieste fatte dal committente si &egrave; deciso di utilizzare il linguaggio di <a href="../QAK/qak.html">QActor (meta)model</a>.
        Questa decisione &egrave; stata fatta in quanto i software forniti dal committente sono stati sviluppati in questo linguaggio.
        Altro motivo della scelta presa &egrave; la presenza di alcuni vantaggi come: 
        <ul>
            <li>minimizzazione dell'abstraction gap (utile visto la natura distribuita che assume il progetto) mediante l'utilizzo di entit&agrave;, che possiamo definire come attori, che comunicano tra loro mediante l'invio di messaggi.</li>
            <li>descrizione delle entit&agrave; formalizzate, cos&igrave; che possano essere compresi direttamente dalla macchina, mediante la costruzione di modelli eseguibili.</li>
        </ul>
    </p>
</div>

<h2>Requirement analysis</h2>
    <div class="remark">
        <h3> Dizionario</h3>  
        <ul>
            <li><ks>WasteService</ks>:si occupa del coordinamento delle attivit&agrave; di raccolta e smistamento dei rifiuti. 
                                    Contiene buona parte della business logic del sistema
            </li>

            <li><ks>Smart devices</ks>:Dispositivo attraverso il quale il Waste-truck comunica al WasteService:
                <ul>
                    <li>Il tipo di materiale trasportato:</li>
                    <ul>
                        <li>PLASTIC</li>
                        <li>GLASS</li>
                    </ul>
                    <li>Kg di materiale</li>
                </ul>
            
            <li><ks>Loadaccept</ks>: la risposta inviata dal <strong>WasteService</strong> se il carico di rifiuti non pu&ograve; essere accettato.
            <k>Reply loadaccept : loadaccpet(_)</k></li>
            
            <li><ks>Loadrejected</ks>: la risposta inviata dal <strong>WasteService</strong> se il carico di rifiuti pu&ograve; essere accettato.
            <k>Reply loadreject : loadreject(_)</k>   </li>
            
            <li><ks>Service area</ks>: una stanza rettangolare, priva di ostacoli interni delimitata da un bordo, dove il robot si muover&agrave;. <br> La stanza deve comprendere le zone <strong>Indoor, PlasticBox, GlassBox, Home</strong>.</li>
            
            <li><ks>Indoor</ks>: porta di ingresso adibita all'operazione di carico dei rifiuti </li>
            
            <li><ks>Transport Trolley</ks>: entit&agrave; utilizzata al fine di comandare il DDR Robot 
            
            <li><ks>PlasticBox</ks>: container adibito al deposito di materiale plastico, con capienza attuale contPB (valore aggiornato ad ogni scarico in Kg) e capacit&agrave; massima pari a MAXPB (valore preimpostato in Kg). Rappresenta la zona dedicata allo scarico di materiale di plastica.</li>
            
            <li><ks>GlassBox</ks>: container adibito al deposito di materiale vetroso, con capienza attuale contGB (valore aggiornato ad ogni scarico in Kg) e capacit&agrave; massima pari a MAXGB (valore preimpostato in Kg). Rappresenta la zona dedicata allo scarico di materiale di vetro.</li>
            
            <li><ks>DDR robot</ks>: Differential Drive Robot, un robot che funge da <strong>Transport Trolley</strong>. 
                <br>&Egrave; in grado di muoversi nell'ambiente eseguendo semplici comandi di spostamento. 
                
            <li><ks>Home location</ks>: posizione di partenza fissa all'interno dell'area di servizio dove si trover&agrave; il robot prima dell'avvio del software e dove torner&agrave; se non ci sono lavori in sospeso.</li>
            
            <li><ks>Deposit action</ks>: rappresenta i task del robot, questa attivit&agrave; pu&ograve; essere suddivisa nelle seguenti fasi:
                <ul>
                    <li>il robot deve spostarsi dalla sua posizione attuale (Home/altro) e raggiungere l'indoor</li>
                    <li>il robot deve raccogliere il carico di rifiuti <strong>(Pickup)</strong></li>
                    <li>il robot deve spostarsi dall'interno all'apposito container (PlasticBox or GlassBox)</li>
                    <li>il robot deve depositare i rifiuti nell'apposito container <strong>(Dropout)</strong></li>
                </ul>
            </li>
            
            <li><ks>Service-manager</ks>: utente che supervisiona lo stato dell'area di servizio utilizzando la <b>WasteServiceStatusGUI</b> </li>
            
            <li><ks>WasteServiceStatusGUI</ks>: Pannello di controllo che permette al <strong>Service-manager</strong> di monitorare e di osservare lo stato del <strong>Service-area</strong>, tra cui: 
                <ul>
                    <li>lo stato attuale del <strong>Transport Trolley</strong> e la sua posizione nella stanza</li>
                    <li>Led On: quando il Transport Trolley: &egrave; fermo (quando distanza rilevata < DLIMIT)</li>
                    <li>lo stato attuale del Led</li>
                </ul>
            </li>
            
            <li><ks>Stato attuale del <strong>Transport Trolley</strong></ks>: rappresentato attraverso il LED e indica lo stato del <strong>Transport Trolley</strong>. Ci sono principalmente 3 modalit&agrave;    
                <ul>
                    <li><strong>Led Off:</strong> quando il <strong>Transport Trolley</strong> &egrave; in HOME</li>
                    <li><strong>Led On:</strong> quando il <strong>Transport Trolley</strong> &egrave; fermo (quando distanza rilevata < DLIMIT)</li>
                    <li><strong>Led Blink:</strong> quando il <strong>Transport Trolley</strong> &egrave; in movimento, o sta scaricando/caricando materiale</li>
                </ul>
            </li>
            
            <li><ks>Warning devices</ks>: un <b>Led</b> fisico che rappresenta lo stato Transport Trolley.
                
            <li><ks>Alarm devices</ks>: un <b>Sonar</b> fisico che funge da rilevatore di distanza, se la distanza misurata &egrave; inferiore a DLIMIT il robot deve essere fermato, verr&agrave; riattivato solo quando la distanza torner&agrave; ad essere maggiore di DLIMIT.
            
            <li><ks>DLIMIT</ks>: distanza limite in cm. Se la distanza attualmente misurata dal Sonar &egrave; minore o uguale a DLIMT, il robot deve fermarsi. Quando la distanza misurata &egrave; maggiore di DLIMIT il robot pu&ograve; muoversi.</li>
            
            <li><ks>TruckLoad</ks>: quantitativo di spazzatura in Kg trasportata dal camion di rifiuti.</li>
 
        </ul>   
        
        <h3>WasteService</h3>
        <p>
            Lo <strong>Smart devices</strong> dopo aver mandato un messaggio di richiesta per chiedere se &egrave;  possibile o desiderare il carico, tramite un metodo che riceve in entrata il <b>truckLoad e truckType</b>.          
            <br>
            <br>
            <k>Request deposit:deposit(truckLoad,truckType)</k>
            <br>

            <br>Successivamente ricever&agrave; dal WasteService l'esito, che pu&ograve; essere <b>LoadAccepted</b> o <b>LoadRejected</b> (dopo aver effettuato i relativi controlli).</li>
            
            <br><br>
            <k>Reply loadaccept : loadaccpet(_)</k>
            <br><k>Reply loadreject : loadreject(_)</k>

            <br><br>Dallo scambio di messaggi,si potr&agrave; assumere che il wastService sar&agrave; un <k>Attore</k>.
        
            <br>Il tutto quindi pu&ograve; essere formalizzato tramite l'attore <u>wasteserviceactor</u> presente nel file <a href="../QAK/V1/wasteservice.qak" target="wasteservice">wasteservice.qak</a>.
            <br>In fase di test si assumera che il truckDriver, sar&agrave; una UI Python che mander&agrave; il messaggio al WastService.
            <br>I test consisteranno nell'invio della richiesta di deposito al WasteService.
            <br>Il wasteService dovr&agrave; rispondere con un <strong>loadAccept</strong> dato che il peso &egrave; inferiore a quello rimanente.
            <br>Il wasteService dovr&agrave; rispondere con un <strong>loadRejecetd</strong> dato che il peso &egrave; superiore a quello rimanente.
            <br>

            <p>
                Si mostrano i <a href="../TestWorkspace/testWastService/test/wasteservice/TestWastService.java" >TestWasteService</a> 
                e il modello del <a href="../TestWorkspace/testWastService/src/wasteService.qak" >WasteService</a> utilizzato.
            </p>


           
        </p>
        <h3>TransporTrolley</h3>
        <p>
            Il committente ha precisato che il transportTrolley <k>non &Egrave; il DDR Robot</k>  ma il Trolley <k>usa </k> il DDR Robot.
            
            
            <br>Il committente fornisce gi&agrave; un ambiente di simulazione che implementa un DDR Robot Virtuale e un attore che si interfaccia con esso
            <br> <strong>Documentazione:</strong> <u>VirtualRobot->WEnv</u>. 
            <br><strong>Progetti:</strong> <u>it.unibo.virtualRobot2020, unibo.wenvUsage22</u>
            
            
            <br>Il committente fornisce gi&agrave; del software relativamente a ci&ograve; in <u>it.unibo.basicrobot22</u>.
            
            <br> Su di esso verranno effettuati dei test al fine di verificare la corretta transizione di stato.
            Il tutto tramite una serie di messaggi che faranno transitare il transportTrolley negli stati di :
            <ul>
                <li>Pickup</li>
                <li>Deposit</li>
                <li>Home</li>
            </ul>
            Il test avr&agrave; successo se la risposta del trolley &egrave; quella aspettata e se lo stato verr&agrave; aggiornato correttamente.
            
            <br>

            <p>
            Si mostrano il <a href="../TestWorkspace/testWastService/test/wasteservice/TestTransportTrolley.java" >TestTransportTrolley</a> 
            e il modello del <a href="../TestWorkspace/testWastService/src/wasteService.qak" >TransportTrolley</a> utilizzato.
            </p>
        </p>
        <h3>Sonar e Led</h3>
        <p>
            <h4>LED</h4>
            Il committente fornisce gi&agrave; del software relativamente al LED in <u>it.unibo.radarSystem22.domain</u>,  <a href="../Prof/led25GpioTurnOff.sh">LedOff</a>, <a href="../Prof/led25GpioTurnOn.sh" >LedOn</a>.
            <br>Il Led pu&ograve; essere formalizzato in  <a href="../Prof/ledqak22.qak" target="led" >LED</a>.
            
            <h4>SONAR</h4>
            Il committente specifica che &egrave; un sensore HC-SR04, anch'esso sar&agrave; attaccato ad un RaspberryPi che emetter&agrave; un evento che invier&agrave;
            la distanza percepita. Inoltre il committente ci fornisce il seguente software: <a href="../Prof/SonarAlone.c" target="led" >SonarAlone.c</a>
            <br>Il committente fornisce gi&agrave; del software relativamente al Sonar in <u>unibo.basicrobot22, it.unibo.radarSystem22.domain, unibo.sonarqak22</u> 
            <br> Il Sonar pu&ograve; essere formalizzato come un attore Qak (visto che permette di usufruire dello scambio di messaggi) in <a href="../Prof/sonarqak22.qak" target="sonar" >unibo.sonarqak22</a>.</li>
            
            <br>
            L'architettura adottata dal Sonar fornita dal committente &egrave; di questo tipo:
             <br>
                 <center>
                     <img src="img\sonarpipenano.png" alt="sonar" style="width:50%">
                 </center>
             <br>
             <p>
                 Dall'architettura fornita possiamo andare a definire gli attori <i>datacleaner</i> e <i>datafilter</i> che hanno il compito di filtrare i dati, erronei o non rilevanti,
                 ed inviare gli eventi di tipo <k> obstacle: obstacle($distance)</k> e di rilevare distanze minori a quella prefissata.
             </p>
             <p>
                 Per quanto riguarda l'avvio del sonar, il tutto avviene tramite dei messaggi di attivazione (<i>sonaractivate</i>) e disattivazione (<i>sonardeactivate</i> ) del funzionamento, 
                 invece per quanto riguarda l'invio dei dati vi &egrave; <k>Event sonar: distance( V ) </k> che pu&ograve; essere emesso tramite i dati forniti dalla simulazione del sonar (<i>sonarSimulator</i>)  o da quello concreto (<i>sonardatasource</i>) e inviato al prossimo attore mediante pipe.
             </p>
             <pre>
                 Dispatch sonaractivate   : info(ARG)
                 Dispatch sonardeactivate : info(ARG)
                 Event    sonar           : distance( V )   //emitted by sonarSimulator or sonardatasource	
             </pre>
             <p>
                Se il Sonar concreto o simulato rileva una distanza minore di DLIMIT invier&agrave; un evento che innescher&agrave; lo stato <i>stopped</i>
                del robot. Dove DLIMT puo essere formalizzata nella forma : <k>Final double DLIMIT</k> 
             </p> 

        </p>
        <h3>Architettura Logica Del Sistema</h3>
        <p>Terminata l'analisi dei requisiti, si fornisce una prima versione dell'architettura del sistema. L'attenzione sar&agrave; posta sulla realizzazzione del business core, che consiste nell'azione di pickup dei rifiuti.</p>
        <center>
            <img src="./img/arc1.jpg" width="50%" height="50%">
        </center>
        <p>Attraverso questa immagine si cerca di formalizzare entrambi i contesti, prima il <a href="../TestWorkspace/testWastService/src/wasteService.qak" >ctxWasteService</a> e poi il <a href="../Prof/basicrobot.qak"> ctxbasicrobot</a>, ricordando che il basicrobot22 &egrave; stato fornito dal committente.</p>
        <p><k>Sonar e Led</k> verranno inseriti nel sistema e nell'architettura in un secondo momento.</p>
        <p>Il test effettuato al ctxWasteService consiste nell'inviare all'attore <k>WasteService</k> il messaggio di avvenuto deposito: <k>Request deposit:deposit(truckLoad,truckType)</k></p>
        <p>Scopo del test &egrave; quello di visionare se:</p>
        <ol>
            <li>la richiesta viene accettata correttamente, e la verifica di ci&ograve; sar&agrave; ottenuta se la risposta al messagio &egrave;: <k>Reply loadaccept : loadaccpet(_)</k>;</li>
            <li>lo stato dei pesi dei contenitori del wasteService si aggiorna correttamente; </li>
            <li>essendo arrivata una richiesta di deposito, il wastService chieder&agrave; al transportTrolley di raggiungere l'indoor con il messaggio  <k>forward transporttrolley -m goto : goto(indoor)</k>. Successivamente verr&agrave; controllato se lo stato del transportTrolley si &egrave; aggiornato correttamente.</li>
        </ol>
        <p>Se tutti e 3 i punti sopra citati si verificano, il test &egrave; superato.</p>
        <p>Si mostra il <a href="../TestWorkspace/testCtxWastService/src/wasteService.qak">ctxWasteService</a> aggiornato e il <a href="../TestWorkspace/testCtxWastService/test/wasteservice/TestctxWasteService.kt">TestctxWasteService</a>.</p>
        <p></p>
    </div>



<h2>Problem analysis</h2>
    <div class="remark">      
        <h3>Service area</h3>
        <div>
            In questa fase &egrave; necessario stabilire una corretta rappresentazione dell'area di servizio. Scelte a priori le posizioni delle zone <ks>INDOOR</ks>, <ks>PlasticBox</ks>, <ks>GlassBox</ks> e <ks>HOME</ks>, la stanza &egrave rappresentabile 
            attraverso un <strong>Sistema Matriciale m x n</strong>: 
                    <pre>
                        1, 1, 1, 1, 1, 1, 1, 1,
                        1, 1, 1, 1, 1, 1, 1, 1,
                        1, 1, r, 0, 0, 0, 0, 1,
                        1, 0, 0, X, 0, 0, 0, 1,
                        1, 0, 0, 0, 0, 0, 0, 1,
                        1, 1, 1, 1, 1, 1, 1, 1, 
                    </pre>
                    Nella rappresentazione di cui sopra precisiamo che:
                    <li>1 : celle gi&agrave; visitate dal robot;
                    <li>r: posizione corrente del robot;
                    <li>0 : cella non ancora visitata;
                    <li>X : cella rappresentante un ostacolo.
                    </li>
                    
                    <br>
                    Si definisce un sistema di riferimento della stanza attraverso un piano cartesiano (X,Y) in cui l'asse X rappresenta la larghezza della stanza e l'asse Y la lunghezza. 
                    La posizione del Transport Trolley e delle aree di interesse saranno quindi espresse come coppie di coordinate (X,Y).
                    <br>
                    <br>
                    <center>
                    <img src="./img/cart.png" width="25%" height="25%" ><br>
                    </center>
                    <br>
                    
        </div>
        <h3>Punti d'interesse</h3>
        <div>
            <p>
               Fase essenziale del progetto sar&agrave; capire come rappresentare e individuare le coordinate dei punti d'interesse(Home, PlasticBox, Indoor, GlassBox).
            </p>
            <p>Potremmo rappresentarle in vari modi:</p>
            <ul>
                <li>
                   Punti su un piano cartesiano (x, y)
                </li>
                <li>
                    Coppia colonna-riga di una matrice A m x n
                </li>
                <li>
                    Tripla di coordinate(i, j, k) 
                    <ul>
                        <li>i e j coordinate matriciali per individuare la posizione corrente del DDR</li>
                        <li>k il verso in cui si sta muovendo il DDR</li>
                    </ul>
                 </li>
            </ul>
            <p>Per le motivazioni precendentemente discusse, &egrave; conveniente utilizzare una rappresentazione matriciale dato che il software <u>unibo.planner22</u>, fornito dal committente, le richiede per una corretta esecuzione.</p>
        
        </div>

        <h3>Robot</h3>
        <div>
            Si dovr&agrave; capire come il robot si dovr&agrave; muovere all'interno dell'aria di servizio e su come determiner&agrave; informazioni. 
            Ogni step verr&agrave; comandato dal messaggio:

            <center>
                <pre>request basicrobot -m step : step(TIME)</pre>
            </center>

            <p>Ci&ograve; porter&agrave; il robot a compiere uno spostamento ad ogni <k>Time</k> (espresso in millisecondi) </p>
            <p>Le soluzioni potrebbero essere:</p>
            <ul>
                <li>Far eseguire un mapping della stanza grazie al software fornito <a href="../Prof/mapperqak22.qak"><k>Mapper</k></a>. Consentir&agrave; di creare la mappa della stanza e ottenere le relative coordinate </li>
                <li>Ottenere la velocit&agrave; del robot (km/h) e le misure della stanza(espressa in metri) attraverso un semplice calcolo matematico, per poi memorizzare i dati calcolati in un file di configurazione, tramite la seguente formula:
                <center>
                    <k>Ur=time*velocity</k>
                </center>
                <br>
                Il risultato ottenuto rappresenter&agrave; un'unit&agrave; robotica, la quale servir&agrave; per individuare il numero di step che il robot potr&agrave; fare. Tale dato si otter&agrave; moltiplicando per le misure della stanza:
                <center>
                    <k>step=Ur*(x,y)[stanza]</k>
                </center>
                <br>
                </li>
                <li>Sfruttare le collissioni per ottenere le coordinate della stanza. Sapendo che il DDR Robot &egrave; equipaggiato con un Sonar, questo pu&ograve; essere usato per riconoscere gli ostacoli(in questo caso il muro). 
                    Il tutto funzionerebbe attraverso il conteggio del numero di volte che il robot riesce a compiere un stepDone, nel momento in cui riceve uno uno stepFail avremmo il numero di step che ha fatto per raggiungere un certo elemento. Iterando questo ragionamento per tutti gli elementi si riuscirebbe a ottenere le coordinate della stanza.
                    </li>
            </ul>
            Tutte le rappresentazioni sono valide. La prima permetterebbe l'utlizzo di un software gi&agrave; fornito, risparmiando calcoli e codice, ma come anche la terza ipotesi,  farebbe  girare il robot "inutilmente" nella stanza. La seconda scelta, invece, ci permetter&agrave; di trovare direttamente le coordinate.
         </div>

        <h3>Rappresentazione nella GUI</h3>
            <div>
                <p>
                    Nella GUI che sar&agrave; fornita dal Service-Manager verranno rappresentati lo stato e posizione del trolley, e lo stato di PlasticBOX e GlassBOX.
                    Per quanto riguarda lo stato dei box, esso sar&agrave; visualizzato mediante le variabili <k> currentLoads[material] (material= glass OR plastic);</k>, le quali verranno messi a confronto con il MAXPB/MAXGB.
                    <br> 
                    Lo stato del trolley all'interno della GUI verr&agrave; rappresentato mediante una pagina web rappresentabile in due modi:
                </p>
                <ul>
                    <li>La stampa a video del "CurrentState":
                        <br>
                        Si vedr&agrave; stampato a schermo lo stato del robot e la suo posizione relativa(o effettiva).
                        <br>
                        <br>
                        <img src="img\state1.png"  width="25%" height="25%" alt="GUI">
                    </li>
                    <li>Rappresentazione grafica (animazione):
                        <br>
                        Si vedr&agrave; un'animazione di una "lampadina" e una mappa dell'area di servizio.
                        <br>
                        <br>
                        <img src="img\state2.png"  width="25%" height="25%" alt="GUI">
                    </li>
                </ul>
                <p>
                    Lo stato e la posizione del trolley e gli stati di PlasticBOX e GlassBOX verranno aggiornati mediante script (javascript) che permetter&agrave; di
                    mostrare a schermo le informazioni pi&ugrave; recenti, attraverso l'utilizzo della parola chiave <k> addEventListener</k>.
                    In fase di test si consiglia la prima opzione, in successive versioni si pu&ograve; optare per la seconda.
                </p></div>
        <h3>Architettura Logica Post-Analisi del Problema</h3>
        <div>
        Nel sistema il WasteService &egrave; il componente controller, ossia quello che contiene le operazioni da svolgere per realizzare le Deposit Actions.
        Il DDR Robot &egrave; collocato sullo stesso contesto del Transport Trolley, dato che cambiando la tecnologia di movimento usata andrebbe modificato anch'esso. 
        LED e Sonar concreti sono collegati al RaspberryPi, di conseguenza stanno su un contesto a parte.
        
        <p> 
            Dopo una prima analisi del problema, da un punto di vista strutturale &egrave; possibile definire il coreBusiness come l'architettura presa in considerazione
            precedentemente, variandola inserendo la comunicazione con il <a href="../Prof/planner22Util.kt"><k>unibo.planner22</k> (mostrato nel capitolo <a href="./Analisi V2.html">precedente</a>) in quanto permette di pianificare le mosse
            da far compiere al TransporTrolley. L'architettura, dunque, si presenter&agrave; in questo modo:  
        </p>
        <br>
        <center>
            <img src="./img/arc2.jpg" alt="architettura_post_an" width="50%" height="50%">
        </center>
        <p>Si mostra il <a href="../TestWorkspace/testCtxWastService/src/wasteService.qak">ctxWasteService</a> aggiornato tenendo conto della nuova architettura.</p>
        
        <p>
            La GUI verr&agrave; discussa e sviluppata in seguito in modo pi&ugrave; approfondito.
        </p>
        <p>
            Restano validi i test:
            <li><a href="../TestWorkspace/testWastService/test/wasteservice/TestTransportTrolley.java" >TestTransportTrolley</a>
            <li><a href="../TestWorkspace/testWastService/test/wasteservice/TestWastService.java" >TestWasteService</a>
            <li><a href="../TestWorkspace/testCtxWastService/test/wasteservice/TestctxWasteService.kt">TestctxWasteService</a>
            </li>
            <br>
            Il planner22, essendo un software fornito dall'azienda, si considera gi&agrave; testato. 
        </p>
    
        </div>

    </div>

<h2>Work To Do</h2>
<div class="remark">
    <ul>
        <li>Progettazione dello Sprint 1: Buinsess Core</li>
        <li>Definire e progettare l'azione di deposito</li>
        <li>Definire e progettare la GUI </li>
        <li>Definire la nuova Architettura Logica</li>
        <li>Definire i nuovi Test Plan</li>
    </ul>
</div>

<!--
<h2>Test plans</h2> 
<h2>Project</h2> 
<h2>Testing</h2> 
<h2>Deployment</h2> 
<h2>Maintenance</h2> 
  -->

<!-- USEFUL
<table style="width:100%" border="1">
<tr>
<td style="width:50%">
</td>
<td></td>
</tr>
</table>
-->
	      	
<br/><br/> 	
</div>  

<div style="background-color:rgba(86, 56, 253, 0.9); width:100%;text-align:left;color:white">
    <table style="border: 0px solid transparent; margin: 0 auto;">
        <tr>
            <th style="width: 50%;">
                    <p>
                        <b>Lorenzo Di Palma</b><br/><br/>
                        <span><b>ISS repo: <a id="issRepo" style="color:white" href="https://github.com/lollofred/iss2022">https://github.com/lollofred/iss2022</a></b></span><br/><br/>
                        Contacts:<br/>
                        e-mail: lorenzo.dipalma2@studio.unibo.it  <br/>
                        GitHub: <a id="github" style="color:white" href="https://github.com/lollofred">lollofred</a><br/>
                    </p>
                        <img src="./img/lorenzo.jpg" alt="Lorenzo Di Palma" width="200px" height="200px">
            </th>
            <th style="width: 50%;">  
                <p>
                <b>Luigi di Nuzzo</b><br/><br/>
                <span><b>ISS repo: <a id="issRepo" style="color:white" href="https://github.com/luigidinuzzo/iss2022">https://github.com/luigidinuzzo/iss2022</a></b></span><br/><br/>
                Contacts:<br/>
                e-mail: luigi.dinuzzo@studio.unibo.it  <br/>
                GitHub: <a id="github" style="color:white" href="https://github.com/luigidinuzzo">luigidinuzzo</a><br/>
                </p>
                 <img src="./img/luigi.jpeg" alt="Luigi di Nuzzo" width="200px" height="200px">             


            </th>
        </tr>
    </table>
</div> 
</body>
</html>